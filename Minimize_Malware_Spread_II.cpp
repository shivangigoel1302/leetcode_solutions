class Solution {
public:
    void dfs(unordered_set<int>&seen,int src,vector<vector<int>>&graph,vector<int>malware){
        for(int i = 0; i < graph.size(); i++){
            if(graph[src][i] && malware[i] == 1 && seen.find(i) == seen.end()){
                seen.insert(i);
                dfs(seen,i,graph,malware);
            }
        }
        return;
    }
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        int n = graph.size();
        vector<int>infectedby[n];
        vector<int>malware(n,1);
        for(int i = 0; i < initial.size(); i++){
            malware[initial[i]] = 0;
        }

        for(int i = 0; i < initial.size(); i++){
            unordered_set<int>seen;
            dfs(seen,initial[i],graph,malware);
            auto it = seen.begin();
            while(it != seen.end()){
                infectedby[*it].push_back(initial[i]);
                it++;
            }
        }

        vector<int>contribution(n,0);
        for(int i = 0; i < n; i++){
            if(infectedby[i].size() == 1){
                contribution[infectedby[i][0]]++;
            }
        }

        int ans = INT_MAX;
        for(int i = 0; i < initial.size(); i++){
            int s = contribution[initial[i]];
            if(ans == INT_MAX){
                ans = initial[i];
            }
            else if(s > contribution[ans]){
                ans = initial[i];
            }
            else if(s == contribution[ans] && initial[i] < ans){
                ans = initial[i];
            }
        }
        return ans;
    }
};
